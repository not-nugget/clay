using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;

using Clay.Types.Element;
using Clay.Types.Error;
using Clay.Types.Functions;
using Clay.Types.Internal;
using Clay.Types.Internal.Interop;
using Clay.Types.Rendering;

namespace Clay;

/// <summary>Exposes the internal bindings to Clay for use in <see cref="ClayContext" /></summary>
internal static partial class Clay
{
    /// <summary>Initialize a new <see cref="ClayContext" /></summary>
    /// <param name="dimensions">Initial dimensions of the created window</param>
    /// <param name="measureTextFunction">Required text measurement function</param>
    /// <param name="errorHandlerCallback">Optional error handler callback delegate to be called if Clay encounters an error</param>
    /// <returns><see cref="ClayContext" /> instance for use in creating your Clay UI</returns>
    internal static ClayContext Initialize(ClayDimensions dimensions, MeasureTextFunction measureTextFunction, ErrorHandlerFunction? errorHandlerCallback)
    {
        ClayContext? context;
        try
        {
            var errorHandler = new ClayErrorHandler();
            if (errorHandlerCallback != null)
                errorHandler.ErrorHandlerFunction = errorHandlerCallback;

            var memorySize = Clay_MinMemorySize();
            var arenaMemoryHandle = new ClayArenaMemoryHandle(memorySize);
            var arena = Clay_CreateArenaWithCapacityAndMemory(memorySize, arenaMemoryHandle.DangerousGetHandle());

            Clay_Initialize(arena, dimensions, errorHandler);
            Clay_SetMeasureTextFunction(measureTextFunction);

            context = new ClayContext(arenaMemoryHandle);
        }
        catch (Exception e)
        {
            throw new ApplicationException("An error occurred while initializing Clay. See InnerException for details", e);
        }

        return context;
    }

    /// <summary>Start a new Clay layout</summary>
    internal static void BeginLayout()
        => Clay_BeginLayout();

    /// <summary>End the current Clay layout</summary>
    /// <returns>A set of commands which may be provided to any renderer of choice to render the Clay UI</returns>
    internal static ClayRenderCommand[] EndLayout()
    {
        var nativeArray    = Clay_EndLayout();
        var renderCommands = new ClayRenderCommand[nativeArray.Length]; //TODO array pooling?

        var    commandSize = Marshal.SizeOf<ClayRenderCommand>();
        IntPtr sourceArrayPtr;

        unsafe
        {
            sourceArrayPtr = new IntPtr(nativeArray.InternalArray);
        }

        for (var i = 0; i < nativeArray.Length; i++)
        {
            var commandPtr = new IntPtr(sourceArrayPtr + i * commandSize);
            renderCommands[i] = Marshal.PtrToStructure<ClayRenderCommand>(commandPtr);
        }

        return renderCommands;
    }

    /// <summary>Opens a new Clay element</summary>
    internal static void OpenElement()
        => Clay__OpenElement();

    public static void OpenTextElement(string text, ref TextElementConfig config)
    {
        using var textBufferHandle = new StringBufferHandle(text);
        var clayString = new ClayString
        {
            Length = text.Length,
            Chars  = textBufferHandle.DangerousGetHandle(),
        };

        Clay__OpenTextElement(clayString, ref config);
    }

    internal static void AttachId(ref ElementId elementId)
    {
        // TODO this will prevent a fatal error, BUT it will cause some issues if ever one tries comparing two ElementHandles, as their IDs will not be set correctly. I do not know if i currently have a way to get the current element's ID generated by clay, or get the current element's data to fetch the ID
        if (string.IsNullOrWhiteSpace(elementId.Value))
            return; // Do nothing if the ID is unset and let Clay generate the ID

        var seed = Clay__GetParentElementId();
        var i    = elementId.Offset;
        
        using var textBufferHandle = new StringBufferHandle(elementId.Value);
        var clayString = new ClayString
        {
            Length = elementId.Value.Length,
            Chars  = textBufferHandle.DangerousGetHandle(),
        };

        var unmanagedElementId = Clay__HashString(clayString, i, seed);
        Clay__AttachId(unmanagedElementId);
        elementId = new ElementId
        {
            Value  = Marshal.PtrToStringUTF8(unmanagedElementId.StringId.Chars, unmanagedElementId.StringId.Length),
            Offset = unmanagedElementId.Offset,
            BaseId = unmanagedElementId.BaseId,
            IdHash = unmanagedElementId.Id,
        };
    }

    internal static void AttachLayoutConfig(LayoutConfig layout)
    {
        var          layoutConfigPtr = Clay__StoreLayoutConfig(layout);
        LayoutConfig layoutConfigRef;
        unsafe
        {
            layoutConfigRef = Unsafe.AsRef<LayoutConfig>((void*)layoutConfigPtr);
        }

        Clay__AttachLayoutConfig(ref layoutConfigRef);
    }

    internal static void AttachElementConfig(ClayElementConfigPointer configPointer)
    {
        IntPtr arenaPtr;
        switch (configPointer.Type)
        {
            case ClayElementConfigType.Rectangle:
                var rectangle = Marshal.PtrToStructure<RectangleElementConfig>(configPointer.ConfigPointer);
                arenaPtr = Clay__StoreRectangleElementConfig(rectangle);
                break;
            case ClayElementConfigType.BorderContainer:
                var border = Marshal.PtrToStructure<BorderElementConfig>(configPointer.ConfigPointer);
                arenaPtr = Clay__StoreBorderElementConfig(border);
                break;
            case ClayElementConfigType.FloatingContainer:
                var floating = Marshal.PtrToStructure<FloatingElementConfig>(configPointer.ConfigPointer);
                arenaPtr = Clay__StoreFloatingElementConfig(floating);
                break;
            case ClayElementConfigType.ScrollContainer:
                var scroll = Marshal.PtrToStructure<ScrollElementConfig>(configPointer.ConfigPointer);
                arenaPtr = Clay__StoreScrollElementConfig(scroll);
                break;
            case ClayElementConfigType.Image:
                var image = Marshal.PtrToStructure<ImageElementConfig>(configPointer.ConfigPointer);
                arenaPtr = Clay__StoreImageElementConfig(image);
                break;
            case ClayElementConfigType.Text:
                var text = Marshal.PtrToStructure<TextElementConfig>(configPointer.ConfigPointer);
                arenaPtr = Clay__StoreTextElementConfig(text);
                break;
            case ClayElementConfigType.None:
                // Don't save or attach anything when not configuring an element
                return;
            case ClayElementConfigType.Custom:
                throw new NotImplementedException("Custom element configuration extensions are not yet supported");
            default:
                throw new InvalidOperationException("Attempted to attach and unknown or unsupported element config type");
        }

        Clay__AttachElementConfig((ClayElementConfigurationUnion)arenaPtr, configPointer.Type);
    }

    /// <summary>If an element is currently open, the pending set configurations are applied</summary>
    internal static void PostConfigureOpenElement()
        => Clay__ElementPostConfiguration();

    /// <summary>Closes the currently open Clay element</summary>
    internal static void CloseElement()
        => Clay__CloseElement();

    internal static void UpdateMouseState(ClayVector2 cursorPosition, bool isMouseDown)
        => Clay_SetPointerState(cursorPosition, isMouseDown);

    internal static void UpdateScrollContainers(bool enableDragScrolling, ClayVector2 mouseWheelDelta, float deltaTime)
        => Clay_UpdateScrollContainers(enableDragScrolling, mouseWheelDelta, deltaTime);

    #region 1:1 Bindings
    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial uint Clay_MinMemorySize();

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial ClayArena Clay_CreateArenaWithCapacityAndMemory(uint capacity, IntPtr memory);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_SetPointerState(ClayVector2 position, [MarshalAs(UnmanagedType.Bool)] bool pointerDown);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_Initialize(ClayArena arena, ClayDimensions dimensions, ClayErrorHandler errorHandler);

    public static void UpdateDimensions(ClayDimensions dimensions)
        => Clay_SetLayoutDimensions(dimensions);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_UpdateScrollContainers([MarshalAs(UnmanagedType.Bool)] bool enableDragScrolling, ClayVector2 scrollDelta, float deltaTime);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_SetLayoutDimensions(ClayDimensions dimensions);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_BeginLayout();

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial ClayRenderCommandArray Clay_EndLayout();

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial ClayElementId Clay_GetElementId(ClayString idString);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial ClayElementId Clay_GetElementIdWithIndex(ClayString idString, uint index);

    [LibraryImport("clay.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static partial bool ClayHovered();

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_OnHover(OnHoverFunctionHandler onHoverFunctionHandler, IntPtr userData);

    [LibraryImport("clay.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static partial bool Clay_PointerOver(ClayElementId elementId);

    //TODO custom marshaller for ClayScrollContainerData
    [DllImport("clay.dll")]
    private static extern ClayScrollContainerData Clay_GetScrollContainerData(ClayElementId id);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_SetMeasureTextFunction(MeasureTextFunction measureTextFunction);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_SetQueryScrollOffsetFunction(QueryScrollOffsetFunction queryScrollOffsetFunction);

    // Accessing each index of the array can be done in managed memory and does not need to interop
    // [LibraryImport("clay.dll", SetLastError = true)]
    // private static partial Clay_RenderCommand *     Clay_RenderCommandArray_Get(Clay_RenderCommandArray* array, int32_t index);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_SetDebugModeEnabled([MarshalAs(UnmanagedType.Bool)] bool enabled);

    [LibraryImport("clay.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static partial bool Clay_IsDebugModeEnabled();

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_SetCullingEnabled([MarshalAs(UnmanagedType.Bool)] bool enabled);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_SetMaxElementCount(int maxElementCount);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay_SetMaxMeasureTextCacheWordCount(int maxMeasureTextCacheWordCount);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay__OpenElement();

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay__CloseElement();

    /// <returns><see cref="IntPtr"/> that points to a Clay managed instance of <see cref="LayoutConfig"/>(<paramref name="config"/>)</returns>
    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial IntPtr Clay__StoreLayoutConfig(LayoutConfig config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay__ElementPostConfiguration();

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay__AttachId(ClayElementId id);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay__AttachLayoutConfig(ref LayoutConfig config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay__AttachElementConfig(ClayElementConfigurationUnion configuration, ClayElementConfigType type);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial IntPtr Clay__StoreRectangleElementConfig(RectangleElementConfig config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial IntPtr Clay__StoreTextElementConfig(TextElementConfig config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial IntPtr Clay__StoreImageElementConfig(ImageElementConfig config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial IntPtr Clay__StoreFloatingElementConfig(FloatingElementConfig config);

    // Not currently supporting custom element config
    // [LibraryImport("clay.dll", SetLastError = true)]
    // private static partial Clay_CustomElementConfig *    Clay__StoreCustomElementConfig(Clay_CustomElementConfig       config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial IntPtr Clay__StoreScrollElementConfig([MarshalUsing(typeof(ScrollElementConfigMarshaller))] ScrollElementConfig config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial IntPtr Clay__StoreBorderElementConfig(BorderElementConfig config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial ClayElementId Clay__HashString(ClayString key, uint offset, uint seed);

    //TODO This just isn't working and I have no idea why. I'm marshalling ClayString when I set an element's ID just fine, but here it explodes
    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial void Clay__OpenTextElement(ClayString content, ref TextElementConfig config);

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial uint Clay__GetParentElementId();

    [LibraryImport("clay.dll", SetLastError = true)]
    private static partial IntPtr Clay__GetOpenLayoutElement();
    #endregion
}